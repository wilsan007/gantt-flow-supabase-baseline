import { createClient } from '@supabase/supabase-js';
import { writeFileSync } from 'fs';
import dotenv from 'dotenv';
dotenv.config();

const supabase = createClient(
  process.env.VITE_SUPABASE_URL,
  process.env.VITE_SUPABASE_SERVICE_ROLE_KEY
);

async function exportProfilesSchema() {
  console.log('üèóÔ∏è EXPORT DU SCH√âMA COMPLET DE LA TABLE PROFILES');
  console.log('================================================\n');

  try {
    // ============================================
    // 1. REQU√äTE SQL DIRECTE POUR LE SCH√âMA
    // ============================================
    console.log('üìã 1. R√©cup√©ration de la structure via SQL direct...');
    
    const schemaQuery = `
      SELECT 
        column_name,
        data_type,
        character_maximum_length,
        is_nullable,
        column_default,
        ordinal_position
      FROM information_schema.columns 
      WHERE table_schema = 'public' 
        AND table_name = 'profiles'
      ORDER BY ordinal_position;
    `;

    const { data: columns, error: columnsError } = await supabase.rpc('exec_sql', {
      sql: schemaQuery
    });

    if (columnsError) {
      console.log('‚ö†Ô∏è Erreur avec exec_sql, utilisation d\'une approche alternative...');
      
      // Approche alternative : analyser un enregistrement existant
      const { data: sampleData, error: sampleError } = await supabase
        .from('profiles')
        .select('*')
        .limit(1);

      if (sampleError) {
        console.log('‚ùå Impossible de r√©cup√©rer les donn√©es:', sampleError.message);
        return;
      }

      if (!sampleData || sampleData.length === 0) {
        console.log('‚ùå Aucune donn√©e dans la table profiles');
        return;
      }

      // Analyser la structure √† partir des donn√©es
      const sample = sampleData[0];
      const inferredColumns = Object.keys(sample).map((key, index) => {
        const value = sample[key];
        let dataType = 'unknown';
        
        if (value === null) {
          dataType = 'nullable';
        } else if (typeof value === 'string') {
          // V√©rifier si c'est un UUID
          if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
            dataType = 'uuid';
          } else if (value.includes('T') && value.includes('Z')) {
            dataType = 'timestamp with time zone';
          } else {
            dataType = 'text';
          }
        } else if (typeof value === 'number') {
          dataType = Number.isInteger(value) ? 'integer' : 'numeric';
        } else if (typeof value === 'boolean') {
          dataType = 'boolean';
        }

        return {
          column_name: key,
          data_type: dataType,
          ordinal_position: index + 1,
          is_nullable: value === null ? 'YES' : 'UNKNOWN',
          column_default: null,
          character_maximum_length: null
        };
      });

      console.log(`‚úÖ ${inferredColumns.length} colonnes analys√©es √† partir des donn√©es`);
      
      await generateSchemaFiles(inferredColumns, [], [], [], []);
      return;
    }

    console.log(`‚úÖ ${columns?.length || 0} colonnes trouv√©es`);

    // ============================================
    // 2. CONTRAINTES
    // ============================================
    console.log('\nüîó 2. R√©cup√©ration des contraintes...');
    
    const constraintsQuery = `
      SELECT 
        constraint_name,
        constraint_type,
        table_name
      FROM information_schema.table_constraints 
      WHERE table_schema = 'public' 
        AND table_name = 'profiles';
    `;

    const { data: constraints, error: constraintsError } = await supabase.rpc('exec_sql', {
      sql: constraintsQuery
    });

    if (constraintsError) {
      console.log('‚ö†Ô∏è Erreur contraintes:', constraintsError.message);
    }

    // ============================================
    // 3. CL√âS
    // ============================================
    console.log('\nüîë 3. R√©cup√©ration des cl√©s...');
    
    const keysQuery = `
      SELECT 
        constraint_name,
        column_name,
        referenced_table_name,
        referenced_column_name
      FROM information_schema.key_column_usage 
      WHERE table_schema = 'public' 
        AND table_name = 'profiles';
    `;

    const { data: keyUsage, error: keyError } = await supabase.rpc('exec_sql', {
      sql: keysQuery
    });

    if (keyError) {
      console.log('‚ö†Ô∏è Erreur cl√©s:', keyError.message);
    }

    // ============================================
    // 4. INDEX (approche alternative)
    // ============================================
    console.log('\nüìä 4. R√©cup√©ration des index...');
    
    const indexQuery = `
      SELECT 
        indexname,
        indexdef
      FROM pg_indexes 
      WHERE schemaname = 'public' 
        AND tablename = 'profiles';
    `;

    const { data: indexes, error: indexError } = await supabase.rpc('exec_sql', {
      sql: indexQuery
    });

    if (indexError) {
      console.log('‚ö†Ô∏è Erreur index:', indexError.message);
    }

    // ============================================
    // 5. POLITIQUES RLS
    // ============================================
    console.log('\nüõ°Ô∏è 5. R√©cup√©ration des politiques RLS...');
    
    const rlsQuery = `
      SELECT 
        policyname,
        cmd,
        qual,
        with_check,
        roles
      FROM pg_policies 
      WHERE schemaname = 'public' 
        AND tablename = 'profiles';
    `;

    const { data: policies, error: policiesError } = await supabase.rpc('exec_sql', {
      sql: rlsQuery
    });

    if (policiesError) {
      console.log('‚ö†Ô∏è Erreur politiques RLS:', policiesError.message);
    }

    // ============================================
    // 6. G√âN√âRATION DES FICHIERS
    // ============================================
    await generateSchemaFiles(
      columns || [],
      constraints || [],
      keyUsage || [],
      indexes || [],
      policies || []
    );

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'export du sch√©ma:', error.message);
  }
}

async function generateSchemaFiles(columns, constraints, keyUsage, indexes, policies) {
  console.log('\nüîß G√©n√©ration des fichiers de sch√©ma...');

  const schema = {
    export_date: new Date().toISOString(),
    table_name: 'profiles',
    schema_name: 'public',
    columns: columns,
    constraints: constraints,
    key_usage: keyUsage,
    indexes: indexes,
    rls_policies: policies
  };

  // ============================================
  // SCRIPT SQL CREATE TABLE
  // ============================================
  let createTableSQL = `-- Sch√©ma complet de la table profiles
-- G√©n√©r√© le: ${new Date().toISOString()}
-- Base: ${process.env.VITE_SUPABASE_URL}

-- Supprimer la table si elle existe (pour recr√©ation)
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Cr√©er la table profiles
CREATE TABLE public.profiles (
`;

  // Ajouter les colonnes
  if (columns && columns.length > 0) {
    const columnDefinitions = columns.map(col => {
      let definition = `    ${col.column_name} ${col.data_type}`;
      
      // Ajouter la longueur pour les types qui en ont besoin
      if (col.character_maximum_length) {
        definition += `(${col.character_maximum_length})`;
      }
      
      // Ajouter NOT NULL si n√©cessaire
      if (col.is_nullable === 'NO') {
        definition += ' NOT NULL';
      }
      
      // Ajouter la valeur par d√©faut
      if (col.column_default) {
        definition += ` DEFAULT ${col.column_default}`;
      }
      
      return definition;
    }).join(',\n');

    createTableSQL += columnDefinitions;
  }

  // Ajouter les contraintes de cl√© primaire
  const primaryKeys = keyUsage?.filter(k => 
    constraints?.some(c => c.constraint_name === k.constraint_name && c.constraint_type === 'PRIMARY KEY')
  );

  if (primaryKeys && primaryKeys.length > 0) {
    const pkColumns = primaryKeys.map(pk => pk.column_name).join(', ');
    createTableSQL += `,\n    PRIMARY KEY (${pkColumns})`;
  }

  createTableSQL += '\n);\n\n';

  // Ajouter les index
  if (indexes && indexes.length > 0) {
    createTableSQL += '-- Index\n';
    indexes.forEach(idx => {
      if (!idx.indexname.includes('_pkey')) {
        createTableSQL += `${idx.indexdef};\n`;
      }
    });
    createTableSQL += '\n';
  }

  // Ajouter les politiques RLS
  if (policies && policies.length > 0) {
    createTableSQL += '-- Activer RLS\nALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;\n\n';
    createTableSQL += '-- Politiques RLS\n';
    policies.forEach(policy => {
      createTableSQL += `CREATE POLICY "${policy.policyname}" ON public.profiles\n`;
      createTableSQL += `    FOR ${policy.cmd}`;
      if (policy.roles && policy.roles.length > 0) {
        createTableSQL += ` TO ${policy.roles.join(', ')}`;
      }
      if (policy.qual) {
        createTableSQL += `\n    USING (${policy.qual})`;
      }
      if (policy.with_check) {
        createTableSQL += `\n    WITH CHECK (${policy.with_check})`;
      }
      createTableSQL += ';\n\n';
    });
  }

  // ============================================
  // SAUVEGARDE DES FICHIERS
  // ============================================
  console.log('\nüíæ Sauvegarde des fichiers...');

  // Fichier JSON complet
  writeFileSync(
    '/home/awaleh/Documents/Wadashaqeen-SaaS/gantt-flow-next/profiles-schema.json',
    JSON.stringify(schema, null, 2),
    'utf8'
  );

  // Fichier SQL
  writeFileSync(
    '/home/awaleh/Documents/Wadashaqeen-SaaS/gantt-flow-next/profiles-schema.sql',
    createTableSQL,
    'utf8'
  );

  // Fichier de documentation
  const documentation = `# Sch√©ma de la table profiles

## Informations g√©n√©rales
- **Table**: profiles
- **Sch√©ma**: public
- **Date d'export**: ${new Date().toISOString()}
- **Nombre de colonnes**: ${columns?.length || 0}
- **Nombre de contraintes**: ${constraints?.length || 0}
- **Nombre d'index**: ${indexes?.length || 0}
- **Nombre de politiques RLS**: ${policies?.length || 0}

## Structure des colonnes

| Colonne | Type | Nullable | D√©faut | Position |
|---------|------|----------|--------|----------|
${columns?.map(col => 
  `| ${col.column_name} | ${col.data_type}${col.character_maximum_length ? `(${col.character_maximum_length})` : ''} | ${col.is_nullable} | ${col.column_default || 'N/A'} | ${col.ordinal_position} |`
).join('\n') || 'Aucune colonne'}

## Contraintes

${constraints?.map(c => 
  `- **${c.constraint_name}** (${c.constraint_type})`
).join('\n') || 'Aucune contrainte'}

## Index

${indexes?.map(idx => 
  `- **${idx.indexname}**: ${idx.indexdef}`
).join('\n') || 'Aucun index'}

## Politiques RLS

${policies?.map(p => 
  `- **${p.policyname}** (${p.cmd}): ${p.qual || p.with_check || 'Aucune condition'}`
).join('\n') || 'Aucune politique RLS'}

## Colonnes d√©taill√©es

${columns?.map(col => `
### ${col.column_name}
- **Type**: ${col.data_type}${col.character_maximum_length ? `(${col.character_maximum_length})` : ''}
- **Nullable**: ${col.is_nullable}
- **D√©faut**: ${col.column_default || 'N/A'}
- **Position**: ${col.ordinal_position}
`).join('\n') || 'Aucune colonne'}
`;

  writeFileSync(
    '/home/awaleh/Documents/Wadashaqeen-SaaS/gantt-flow-next/profiles-schema.md',
    documentation,
    'utf8'
  );

  console.log('‚úÖ Fichiers de sch√©ma cr√©√©s:');
  console.log('   üìÑ profiles-schema.json - Sch√©ma complet en JSON');
  console.log('   üóÉÔ∏è profiles-schema.sql - Script CREATE TABLE complet');
  console.log('   üìñ profiles-schema.md - Documentation lisible');

  // ============================================
  // R√âSUM√â
  // ============================================
  console.log('\nüìä R√âSUM√â DU SCH√âMA:');
  console.log(`   üìã Colonnes: ${columns?.length || 0}`);
  console.log(`   üîó Contraintes: ${constraints?.length || 0}`);
  console.log(`   üìä Index: ${indexes?.length || 0}`);
  console.log(`   üõ°Ô∏è Politiques RLS: ${policies?.length || 0}`);

  if (columns && columns.length > 0) {
    console.log('\nüìã D√©tail des colonnes:');
    columns.forEach(col => {
      console.log(`   ${col.ordinal_position}. ${col.column_name} (${col.data_type}) - ${col.is_nullable === 'NO' ? 'NOT NULL' : 'NULLABLE'}`);
    });
  }
}

exportProfilesSchema();
