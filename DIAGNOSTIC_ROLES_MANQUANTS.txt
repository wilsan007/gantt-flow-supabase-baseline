================================================================================
üîç DIAGNOSTIC: PROBL√àME "AUCUN R√îLE ASSIGN√â"
================================================================================

Date: 9 novembre 2025
Probl√®me: Utilisateur invit√© par Super Admin arrive sur une page "Acc√®s refus√©"
Message: "Aucun r√¥le assign√©" + "Acc√®s requis: canAccessTasks"

================================================================================
üìä ANALYSE DU PROBL√àME
================================================================================

1. **Edge Function handle-email-confirmation FONCTIONNE CORRECTEMENT**
   ‚úÖ Cr√©ation du tenant
   ‚úÖ Cr√©ation du user_role avec role_id de "tenant_admin"
   ‚úÖ Cr√©ation du profil avec role = 'tenant_admin'
   ‚úÖ Cr√©ation de l'employ√©

2. **Le hook useUserRoles NE TROUVE PAS LES R√îLES**
   - Requ√™te: `SELECT * FROM user_roles WHERE user_id = ? AND is_active = true`
   - R√©sultat: userRoles.length === 0
   - Cons√©quence: canAccessTasks = false

3. **CAUSES POSSIBLES:**

   A. **RLS Policy bloque l'acc√®s √† user_roles**
      - La policy sur user_roles peut filtrer par tenant_id
      - L'utilisateur n'a peut-√™tre pas le bon tenant_id dans ses m√©tadonn√©es
      - La policy ne reconna√Æt pas l'utilisateur comme ayant acc√®s

   B. **M√©tadonn√©es utilisateur incorrectes**
      - user.user_metadata.tenant_id manquant ou incorrect
      - user.app_metadata.tenant_id manquant ou incorrect
      - L'utilisateur n'est pas reconnu comme membre du tenant

   C. **Timing/Cache**
      - Les donn√©es sont cr√©√©es mais pas encore visibles (propagation)
      - Le cache de Supabase n'est pas √† jour
      - L'utilisateur doit se d√©connecter/reconnecter

================================================================================
üîß SOLUTIONS √Ä TESTER
================================================================================

**SOLUTION 1: V√©rifier les RLS policies sur user_roles**

Ex√©cuter dans Supabase SQL Editor:

```sql
-- 1. V√©rifier les policies existantes
SELECT 
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies
WHERE tablename = 'user_roles'
ORDER BY policyname;

-- 2. V√©rifier si la policy filtre par tenant
-- Si oui, elle peut bloquer l'acc√®s si tenant_id dans JWT ne match pas

-- 3. Corriger la policy pour SELECT (si n√©cessaire)
DROP POLICY IF EXISTS "user_roles_select_policy" ON public.user_roles;

CREATE POLICY "user_roles_select_policy" 
ON public.user_roles
FOR SELECT
USING (
  -- Permettre √† l'utilisateur de voir SES propres r√¥les
  auth.uid() = user_id
);

-- Puis tester la requ√™te manuellement
SELECT 
  ur.id,
  ur.user_id,
  ur.role_id,
  ur.is_active,
  ur.tenant_id,
  ur.created_at,
  r.name as role_name
FROM user_roles ur
INNER JOIN roles r ON r.id = ur.role_id
WHERE ur.user_id = auth.uid()
  AND ur.is_active = true;
```

**SOLUTION 2: V√©rifier les m√©tadonn√©es utilisateur**

Ex√©cuter dans Supabase SQL Editor:

```sql
-- V√©rifier l'utilisateur avec son email
SELECT 
  id,
  email,
  email_confirmed_at,
  raw_user_meta_data,
  raw_app_meta_data
FROM auth.users
WHERE email = 'EMAIL_UTILISATEUR_ICI'
LIMIT 1;

-- V√©rifier les donn√©es cr√©√©es pour cet utilisateur
-- Remplacer USER_ID par l'ID trouv√© ci-dessus
SELECT 
  'profile' as type,
  p.user_id,
  p.tenant_id,
  p.full_name,
  p.role
FROM profiles p
WHERE p.user_id = 'USER_ID_ICI'

UNION ALL

SELECT 
  'user_role' as type,
  ur.user_id,
  ur.tenant_id,
  r.name as full_name,
  ur.is_active::text as role
FROM user_roles ur
INNER JOIN roles r ON r.id = ur.role_id
WHERE ur.user_id = 'USER_ID_ICI'

UNION ALL

SELECT 
  'employee' as type,
  e.user_id,
  e.tenant_id,
  e.full_name,
  e.status as role
FROM employees e
WHERE e.user_id = 'USER_ID_ICI';
```

**SOLUTION 3: Mettre √† jour les m√©tadonn√©es de l'utilisateur**

Si tenant_id manque dans raw_user_meta_data ou raw_app_meta_data:

```sql
-- R√©cup√©rer le tenant_id depuis le profil
WITH user_tenant AS (
  SELECT user_id, tenant_id
  FROM profiles
  WHERE email = 'EMAIL_UTILISATEUR_ICI'
  LIMIT 1
)
UPDATE auth.users
SET 
  raw_user_meta_data = jsonb_set(
    COALESCE(raw_user_meta_data, '{}'::jsonb),
    '{tenant_id}',
    to_jsonb((SELECT tenant_id FROM user_tenant))
  ),
  raw_app_meta_data = jsonb_set(
    COALESCE(raw_app_meta_data, '{}'::jsonb),
    '{tenant_id}',
    to_jsonb((SELECT tenant_id FROM user_tenant))
  )
WHERE id = (SELECT user_id FROM user_tenant);
```

**SOLUTION 4: D√©connecter/Reconnecter**

L'utilisateur doit:
1. Se d√©connecter compl√®tement
2. Vider le cache du navigateur (ou utiliser mode priv√©)
3. Se reconnecter avec le lien d'invitation
4. Les m√©tadonn√©es JWT seront mises √† jour

**SOLUTION 5: Modifier handle-email-confirmation pour mettre √† jour user_metadata**

Ajouter dans handle-email-confirmation apr√®s la cr√©ation du profil (ligne ~1195):

```typescript
// Mettre √† jour les m√©tadonn√©es utilisateur avec tenant_id
console.log('üîÑ Mise √† jour m√©tadonn√©es utilisateur avec tenant_id...');
const { error: metadataError } = await supabaseAdmin.auth.admin.updateUserById(
  user.id,
  {
    user_metadata: {
      ...user.raw_user_meta_data,
      tenant_id: invitation.tenant_id,
      role: 'tenant_admin',
      tenant_name: validatedCompanyName
    },
    app_metadata: {
      ...user.raw_app_meta_data,
      tenant_id: invitation.tenant_id,
      role: 'tenant_admin'
    }
  }
);

if (metadataError) {
  console.error('‚ö†Ô∏è Erreur mise √† jour m√©tadonn√©es (non critique):', metadataError);
} else {
  console.log('‚úÖ M√©tadonn√©es utilisateur mises √† jour avec tenant_id');
}
```

================================================================================
üéØ PLAN D'ACTION RECOMMAND√â
================================================================================

1. **IMM√âDIAT** - V√©rifier les RLS policies sur user_roles (Solution 1)
2. **IMM√âDIAT** - V√©rifier les m√©tadonn√©es utilisateur (Solution 2)
3. **SI N√âCESSAIRE** - Mettre √† jour manuellement les m√©tadonn√©es (Solution 3)
4. **CORRECTIF PERMANENT** - Modifier handle-email-confirmation (Solution 5)
5. **TEST** - Demander √† l'utilisateur de se d√©connecter/reconnecter (Solution 4)

================================================================================
üìù NOTES SUPPL√âMENTAIRES
================================================================================

- Le processus de cr√©ation fonctionne (tenant, user_role, profile, employee cr√©√©s)
- Le probl√®me est UNIQUEMENT dans la r√©cup√©ration des r√¥les c√¥t√© frontend
- C'est probablement un probl√®me de RLS ou de m√©tadonn√©es JWT
- Une fois corrig√©, tous les nouveaux utilisateurs invit√©s fonctionneront

================================================================================
üîó FICHIERS CONCERN√âS
================================================================================

Backend:
- supabase/functions/handle-email-confirmation/index.ts (ligne 1195)

Frontend:
- src/hooks/useUserRoles.ts (ligne 33-47)
- src/hooks/useRoleBasedAccess.ts (ligne 111)

Database:
- Tables: user_roles, profiles, auth.users
- Policies RLS sur user_roles

================================================================================
