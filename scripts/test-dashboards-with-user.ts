/**
 * Script de Test - Dashboards avec Utilisateur Sp√©cifique
 * Utilise SERVICE_ROLE_KEY pour contourner RLS et tester avec vraies donn√©es
 */

import { config } from 'dotenv';
import { createClient } from '@supabase/supabase-js';
import { exportToCSV, formatDateForExport, formatCurrencyForExport, convertToCSV } from '../src/lib/exportUtils.js';
import { exportTableToPDF, exportHybridPDF } from '../src/lib/pdfExportUtils.js';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Charger .env
config({ path: path.join(__dirname, '../.env') });

// Configuration Supabase avec SERVICE ROLE (bypass RLS)
const SUPABASE_URL = process.env.VITE_SUPABASE_URL || 'https://qliinxtanjdnwxlvnxji.supabase.co';
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || '';

if (!SUPABASE_SERVICE_KEY) {
  console.error('‚ùå ERREUR: SUPABASE_SERVICE_ROLE_KEY manquant dans .env');
  console.log('\nüí° Ajoutez dans .env:');
  console.log('SUPABASE_SERVICE_ROLE_KEY=votre_service_role_key\n');
  process.exit(1);
}

// Client Supabase avec SERVICE ROLE (bypass RLS)
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// USER ID sp√©cifique √† tester
const TEST_USER_ID = '5c5731ce-75d0-4455-8184-bc42c626cb17';

// Dossier de sortie
const OUTPUT_DIR = path.join(__dirname, '../test-outputs');

if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// =====================================================
// R√âCUP√âRER LE TENANT DE L'UTILISATEUR
// =====================================================

async function getUserTenant() {
  console.log(`üîç Recherche du tenant pour user: ${TEST_USER_ID}`);
  
  const { data: profile, error } = await supabase
    .from('profiles')
    .select('tenant_id, full_name, role')
    .eq('user_id', TEST_USER_ID)
    .single();

  if (error) {
    console.error('‚ùå Erreur r√©cup√©ration profil:', error.message);
    return null;
  }

  if (!profile?.tenant_id) {
    console.error('‚ùå Aucun tenant trouv√© pour cet utilisateur');
    return null;
  }

  console.log(`‚úÖ Utilisateur: ${profile.full_name}`);
  console.log(`‚úÖ R√¥le: ${profile.role}`);
  console.log(`‚úÖ Tenant ID: ${profile.tenant_id}`);

  return profile.tenant_id;
}

// =====================================================
// TEST DASHBOARD PROJETS
// =====================================================

async function testProjectsDashboard(tenantId: string) {
  console.log('\nüìä TEST DASHBOARD PROJETS\n' + '='.repeat(50));

  try {
    // R√©cup√©rer les projets du tenant
    const { data: projects, error } = await supabase
      .from('projects')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    console.log(`‚úÖ ${projects?.length || 0} projets r√©cup√©r√©s`);

    if (!projects || projects.length === 0) {
      console.log('‚ö†Ô∏è  Aucun projet - Cr√©ez des projets dans l\'application');
      return { success: true, projectsCount: 0, note: 'Pas de donn√©es' };
    }

    // Calculer m√©triques
    const totalProjects = projects.length;
    const activeProjects = projects.filter(p => p.status === 'active').length;
    const completedProjects = projects.filter(p => p.status === 'completed').length;
    const overdueProjects = projects.filter(p => {
      if (p.status === 'completed') return false;
      return p.end_date && new Date(p.end_date) < new Date();
    }).length;

    // Dur√©e moyenne
    const completedWithDates = projects.filter(
      p => p.status === 'completed' && p.start_date && p.end_date
    );
    
    const avgDuration = completedWithDates.length > 0
      ? Math.round(
          completedWithDates.reduce((sum, p) => {
            const start = new Date(p.start_date!);
            const end = new Date(p.end_date!);
            const days = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
            return sum + days;
          }, 0) / completedWithDates.length
        )
      : 0;

    console.log(`
üìà M√âTRIQUES CALCUL√âES:
   - Total: ${totalProjects}
   - Actifs: ${activeProjects}
   - Termin√©s: ${completedProjects}
   - En retard: ${overdueProjects}
   - Dur√©e moyenne: ${avgDuration}j
    `);

    // Export CSV
    console.log('üìÑ G√©n√©ration CSV...');
    const csvData = projects.map(p => ({
      Nom: p.name || 'Sans nom',
      Description: p.description || '',
      Statut: p.status || 'N/A',
      Priorit√©: p.priority || 'N/A',
      'Date d√©but': formatDateForExport(p.start_date),
      'Date fin': formatDateForExport(p.end_date),
      Progression: p.progress || 0,
      Budget: formatCurrencyForExport(p.budget),
    }));

    const csvContent = convertToCSV(csvData);
    const csvPath = path.join(OUTPUT_DIR, `projets-${tenantId.substring(0, 8)}-${Date.now()}.csv`);
    fs.writeFileSync(csvPath, '\uFEFF' + csvContent);
    console.log(`‚úÖ CSV: ${path.basename(csvPath)}`);

    // Export PDF Complet
    console.log('üìÑ G√©n√©ration PDF Complet...');
    const metrics = [
      { label: 'Total Projets', value: totalProjects },
      { label: 'Actifs', value: activeProjects },
      { label: 'Termin√©s', value: completedProjects },
      { label: 'En Retard', value: overdueProjects },
      { label: 'Dur√©e Moyenne', value: `${avgDuration}j` },
    ];

    const pdfData = projects.slice(0, 20).map(p => ({
      nom: p.name || 'Sans nom',
      statut: p.status || 'N/A',
      priorite: p.priority || 'N/A',
      debut: formatDateForExport(p.start_date),
      fin: formatDateForExport(p.end_date),
      progression: `${p.progress || 0}%`,
    }));

    await exportHybridPDF(
      metrics,
      pdfData,
      [
        { header: 'Nom', dataKey: 'nom' },
        { header: 'Statut', dataKey: 'statut' },
        { header: 'Priorit√©', dataKey: 'priorite' },
        { header: 'D√©but', dataKey: 'debut' },
        { header: 'Fin', dataKey: 'fin' },
        { header: 'Prog.', dataKey: 'progression' },
      ],
      {
        title: 'TEST R√âEL - Rapport Projets',
        subtitle: `Donn√©es utilisateur r√©el ‚Ä¢ ${totalProjects} projets`,
        filename: path.join(OUTPUT_DIR, `projets-complet-${tenantId.substring(0, 8)}-${Date.now()}.pdf`),
        footer: `Test avec user ${TEST_USER_ID.substring(0, 8)}...`,
      }
    );
    console.log('‚úÖ PDF Complet g√©n√©r√©');

    return {
      success: true,
      projectsCount: totalProjects,
      metrics: { totalProjects, activeProjects, completedProjects, overdueProjects, avgDuration },
    };

  } catch (error: any) {
    console.error('‚ùå Erreur:', error.message);
    return { success: false, error: error.message };
  }
}

// =====================================================
// TEST DASHBOARD RH
// =====================================================

async function testHRDashboard(tenantId: string) {
  console.log('\nüë• TEST DASHBOARD RH\n' + '='.repeat(50));

  try {
    // R√©cup√©rer employ√©s
    const { data: employees, error: empError } = await supabase
      .from('employees')
      .select('*')
      .eq('tenant_id', tenantId);

    if (empError) throw empError;

    // R√©cup√©rer cong√©s
    const { data: leaveRequests, error: leaveError } = await supabase
      .from('leave_requests')
      .select('*')
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false });

    if (leaveError) throw leaveError;

    console.log(`‚úÖ ${employees?.length || 0} employ√©s`);
    console.log(`‚úÖ ${leaveRequests?.length || 0} demandes de cong√©s`);

    if (!employees || employees.length === 0) {
      console.log('‚ö†Ô∏è  Aucun employ√© - Module RH non utilis√©');
      return { success: true, employeesCount: 0, note: 'Pas de donn√©es RH' };
    }

    // Calculer m√©triques
    const totalEmployees = employees.length;
    const pendingRequests = leaveRequests?.filter(r => r.status === 'pending').length || 0;
    const approvedRequests = leaveRequests?.filter(r => r.status === 'approved').length || 0;

    console.log(`
üìà M√âTRIQUES RH:
   - Total Employ√©s: ${totalEmployees}
   - Demandes en attente: ${pendingRequests}
   - Demandes approuv√©es: ${approvedRequests}
    `);

    // Export CSV
    console.log('üìÑ G√©n√©ration CSV Cong√©s...');
    const csvData = (leaveRequests || []).map(r => {
      const employee = employees.find(e => e.user_id === r.employee_id);
      return {
        Employ√©: employee?.full_name || 'Inconnu',
        'Date d√©but': formatDateForExport(r.start_date),
        'Date fin': formatDateForExport(r.end_date),
        'Nombre jours': r.total_days || 0,
        Statut: r.status === 'approved' ? 'Approuv√©e' : r.status === 'rejected' ? 'Rejet√©e' : 'En attente',
        Raison: r.reason || '',
      };
    });

    const csvContent = convertToCSV(csvData);
    const csvPath = path.join(OUTPUT_DIR, `conges-${tenantId.substring(0, 8)}-${Date.now()}.csv`);
    fs.writeFileSync(csvPath, '\uFEFF' + csvContent);
    console.log(`‚úÖ CSV: ${path.basename(csvPath)}`);

    // Export PDF
    if (leaveRequests && leaveRequests.length > 0) {
      console.log('üìÑ G√©n√©ration PDF RH...');
      const pdfData = leaveRequests.slice(0, 20).map(r => {
        const employee = employees.find(e => e.user_id === r.employee_id);
        return {
          employe: employee?.full_name || 'Inconnu',
          debut: formatDateForExport(r.start_date),
          fin: formatDateForExport(r.end_date),
          jours: (r.total_days || 0).toString(),
          statut: r.status === 'approved' ? 'Approuv√©e' : r.status === 'rejected' ? 'Rejet√©e' : 'En attente',
        };
      });

      await exportTableToPDF(
        pdfData,
        [
          { header: 'Employ√©', dataKey: 'employe', width: 50 },
          { header: 'D√©but', dataKey: 'debut', width: 30 },
          { header: 'Fin', dataKey: 'fin', width: 30 },
          { header: 'Jours', dataKey: 'jours', width: 20 },
          { header: 'Statut', dataKey: 'statut', width: 35 },
        ],
        {
          title: 'TEST R√âEL - Rapport Cong√©s',
          subtitle: `Donn√©es utilisateur r√©el ‚Ä¢ ${leaveRequests.length} demandes`,
          filename: path.join(OUTPUT_DIR, `conges-${tenantId.substring(0, 8)}-${Date.now()}.pdf`),
          footer: `Test avec user ${TEST_USER_ID.substring(0, 8)}...`,
        }
      );
      console.log('‚úÖ PDF g√©n√©r√©');
    }

    return {
      success: true,
      employeesCount: totalEmployees,
      requestsCount: leaveRequests?.length || 0,
      metrics: { totalEmployees, pendingRequests, approvedRequests },
    };

  } catch (error: any) {
    console.error('‚ùå Erreur:', error.message);
    return { success: false, error: error.message };
  }
}

// =====================================================
// EX√âCUTION
// =====================================================

async function runTests() {
  console.log('\n' + '='.repeat(60));
  console.log('üß™ TEST DASHBOARDS AVEC UTILISATEUR R√âEL');
  console.log('='.repeat(60));
  console.log(`üë§ User ID: ${TEST_USER_ID}`);
  console.log(`üìÅ Outputs: ${OUTPUT_DIR}\n`);

  // 1. R√©cup√©rer tenant
  const tenantId = await getUserTenant();
  if (!tenantId) {
    console.error('\n‚ùå Impossible de continuer sans tenant');
    process.exit(1);
  }

  const results: any = {
    timestamp: new Date().toISOString(),
    userId: TEST_USER_ID,
    tenantId,
    tests: {},
  };

  // 2. Test Projets
  const projectsResult = await testProjectsDashboard(tenantId);
  results.tests.projects = projectsResult;

  // 3. Test RH
  const hrResult = await testHRDashboard(tenantId);
  results.tests.hr = hrResult;

  // 4. R√©sum√©
  console.log('\n' + '='.repeat(60));
  console.log('üìä R√âSUM√â DES TESTS R√âELS');
  console.log('='.repeat(60));
  console.log(`
‚úÖ Dashboard Projets: ${projectsResult.success ? 'SUCC√àS' : '√âCHEC'}
   ${projectsResult.projectsCount} projets trouv√©s
   ${projectsResult.metrics ? `M√©triques calcul√©es: ${JSON.stringify(projectsResult.metrics, null, 2)}` : ''}

‚úÖ Dashboard RH: ${hrResult.success ? 'SUCC√àS' : '√âCHEC'}
   ${(hrResult as any).employeesCount || 0} employ√©s trouv√©s
   ${(hrResult as any).requestsCount || 0} demandes de cong√©s

üìÅ Fichiers g√©n√©r√©s dans: ${OUTPUT_DIR}
  `);

  // 5. Rapport JSON
  const reportPath = path.join(OUTPUT_DIR, `test-report-real-${Date.now()}.json`);
  fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
  console.log(`üìÑ Rapport d√©taill√©: ${path.basename(reportPath)}\n`);

  // 6. Liste des fichiers
  const files = fs.readdirSync(OUTPUT_DIR)
    .filter(f => f.includes(tenantId.substring(0, 8)))
    .sort();
  
  console.log('üìã Fichiers g√©n√©r√©s:');
  files.forEach(f => console.log(`   - ${f}`));

  return results;
}

// Ex√©cuter
runTests()
  .then(() => {
    console.log('\n‚úÖ Tests termin√©s avec succ√®s\n');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Erreur fatale:', error);
    process.exit(1);
  });
